STSEG SEGMENT PARA STACK "STACK"
STSEG ENDS

DSEG SEGMENT PARA PUBLIC "DATA"
	TEN_DW DW 10 ; Хак для того что бы потом принудить команду MUL к умножению 2-х 16-ти битных операндов
	StringBuffer DB 7, ?, 6 dup('*') ; место для буфера
	StartMsg DB "Enter the number from -32767 to 32767 please: $" ; знак доллара в конце строки нужен по спецификации процедуры для вывода строки. Это типа ноль-терминатора
	ErrorMsg DB "Invalid Input!",10,13,"Correct format is [+-][0-9]+ from -32767 to 32767",10,13,"$"
	NumberBuffer DW 0
DSEG ENDS

CSEG SEGMENT PARA PUBLIC "CODE"
ASSUME CS: CSEG, DS: DSEG, SS: STSEG		
	MAIN PROC FAR 		
		
	MOV AX, DSEG
	MOV DS, AX    		
	
beginLabel:	
	call ReadlnNum ; считывает число с клавиатуры  
	call ConvertNum ; конвертируем число из текстового вида в двоичный
	call PrintNum ; выводим двоичное число на экран
		
	MOV AX, 4C00h ; ah=4Ch - под-функция для завершения программы
    INT 21h
	MAIN ENDP    
    
	ReadlnNum PROC
	
		; ВЫВОД СТРОКИ НА ЭКРАН С ПОМОЩЬЮ ФУНКЦИИ ДОСа		
      
		LEA  DX, StartMsg  ; Записываем адрес начала строки в DX
		mov  ah, 9        ; ah=9 - под-функция для вывода строк
		int  21h         ; зовем ДОС что бы выполнил
		
		
		; СЧИТЫВАНИЕ СТРОКИ С ЭКРАНА С ПОМОЩЬЮ ФУНКЦИИ ДОСа
		
		LEA DX, StringBuffer ; Записываем адрес начала буффер-строки в DX
		MOV ah, 10 ; ah=10 - под-функция для ввода строк
		INT 21h 
		
		; выводим на экран перевод строки
		
		MOV AL, 10 ; символ перевода строки \n
		INT 29h ; вывод символа на экран
		MOV AL, 13 ; символ возвращения каретки \r
		INT 29h
		
		RET ; выход из процедуры
	ReadlnNum ENDP
	
	ConvertNum PROC
		
		XOR BX, BX ; тут будем накапливать результат
		XOR CX, CX ; Для счетчика цикла
		XOR DI, DI ; для флага
		
		MOV CL, StringBuffer + 1 ; Счётчик повторений цикла == сколько символов считали
		
		mov al, StringBuffer + 2 ; первый введеный символ
		cmp al, '-' ; если это был минус
		je remSign ; прыгаем
		cmp al, '+' ; или был плюс
		je remSign ; прыгаем
		jmp noSign ; этот прыжок выполнится если мы не прыгнули до этого
	
	remSign:
		MOV DI, 1 ; записываем в DI единицу. это будет наш сигнал о том что число было со знаком
		
	noSign:
		MOV SI, CX ; записываем в SI длинну введенной строки (SI будет нашем КУРСОРОМ)
		ADD SI, 1 ; добавляем единицу (смешаемся на один символ вправо) p.s. я напоминаю что у нас первый два символа служебные, это максимальная длина строки и фактическая длина строки
			
	symbolLoop:							

		cmp CX, DI ; прикол этой строки в том что если у нас число было без знака		
		je handleSign ; то этот джамп никогда не выполнится, а если было со знаком выполнится когда дойдем до него(до первого символа)) ^_^
			
		XOR AX, AX ; очищаем AX
		MOV AL, StringBuffer[SI] ; записываем в AL текущий символ
    SUB AL, '0' ; превращаем символ в цифру
      
    cmp al, 0
		jl shitHappens
		cmp al, 9
		jg shitHappens			
    jmp noShit
		
  shitHappens:
		lea dx, ErrorMsg
		mov ah, 9
		int 21h
		jmp beginLabel
		

  noShit:      		
					
		cmp cl, StringBuffer + 1 ; если мы сейчас разруливаем последний символ то его не нужно будет домножать на 10, поэтому мы проверяем или тестим последний символ
		je endImul ; если да, то прыгаем в конец цикла
			
		push CX		; если нет то сохраняем CX
				
		mov dl, StringBuffer + 1 ; записываем в DL длину введенной строки (напр. 5)
		sub dl, cl ; отнимаем от нее текущий символ (напр. 3) p.s. результат запищется в DL
		mov cl, dl ; записываем в CL сколько раз нужно домножить на 10 (напр. 5 - 3 = 2)
		
		imulLoop:						
			MUL TEN_DW ; домножаем на 10, результат будет хранится в паре DX:AX , но наши числа не выйдут за пределы 16 бит, поэтому на DX просто забиваем
			loop imulLoop
			
		pop CX ; возвращаем значение внешнего счетчика цикла
			
	endImul:
	
		DEC SI ; Уменьшаем значение SI
		ADD BX, AX ; накапливаем результат
		jo shitHappens ; проверяем переполнение
		
	LOOP symbolLoop 

	saveResult:			
		
		MOV NumberBuffer, BX ; записываем накопленный результат в буфер
		RET	; Завершаем процедуру

	handleSign:	; сюда мы прыгнем если у нас был знак
		mov al, StringBuffer + 2 ; записываем в AL знак
		cmp al, '-' ; смотрим или это был минус
		jne saveResult ; если это не минус то прыгаем сразу
		neg BX ; если был минус, то инвертируем накопленный результат
		jmp saveResult	
	
	ConvertNum ENDP
  
	PrintNum PROC  		  			
		MOV BX, NumberBuffer ; заносим в BX число из буфера
		OR BX, BX ; делаем это для того изменить флаг знака SF
		JNS M1 ; если флаг знака был 0 (т.е. число положительное) то идем в M1
		MOV AL, "-" ; если число было отрицательным 
		INT 29H ; то выводим минус на экран
		NEG BX ; инвертируем число
	M1:
		MOV AX, BX ; записываем число в AX (нужно будет для деления)
		XOR CX, CX ; обнуляем CX (нужно будет для цикла)
		MOV BX, 10 ; записываем в BX 10 (это будет наш делитель)
	M2:
		XOR DX, DX ; т.к. результат деления будет записан в паре AX:DX (Целая часть:Остача) на каждой итерации обнуляем остачу
		DIV BX ; делим AX на BX (т.е. на 10)
		ADD DL, "0" ; добавляем к остаче код символа 0 (что бы можно было вывести на экран)
		PUSH DX ; записываем этот символ в стек
		INC CX ; увеличиваем CX (CX == количество символов для вывода)
		TEST AX, AX ; проверяем или AX не равен 0 (можно было написать cmp AX, 0 , но test ax,ax типа быстрее)
		JNZ M2 ; если не ноль то делим опять
	M3:
		POP AX ; достаем символ из стека
		INT 29H ; выводим на экран
		LOOP M3 
		
		MOV AL, 13 ; возращаем каретку на начало строки (это чисто для косметического эффекта)
		INT 29H 
		
		RET
	PrintNum ENDP  
	
CSEG ENDS
END MAIN